[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18366123&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.
Software Emgineering is the the process of designing, building, testing and maintaining different types of softwares in tech.
The importance of software engineering are :
1. problem solving.
   software engineering entails  a variety of critical thinking and problem solving skills.To overcome complex challenges requires a methodical, logic based approach to identifying technical issues and improving processes. Through software engineering, you can desigh, innovate and create solutions on such complex problems.
   2. levaraging technology
      software engineering has a large virtual toolbox of technologies that makes it easy to design and innovate solutions. using critical thinking and technological expertise, a software engineer can create software systems  that drive economic and societal progress such as development methods,libraries of softwares and frameworks.
      3. global research accessibility
         many aspects of digital connectivity and inclusivity benefits gtreat time through software engineering.the increased access to the internet and mobile tech has grown the reach of digital software, making it readily available to billions of people.
         4. scalability and flexibility
            software engineering is critical in supporting business growth and innovation. as businesses grow, so do the needs of their software systems.a good software engineeer recognises the needs and therefore will design with scalability in mind, so that the systems can handle an increased load withouth affecting the performance.


Identify and describe at least three key milestones in the evolution of software engineering.
the key milestones in the evolution of software engineering are:
1. the rise of object oriented programing(OOP)
2. the increasing prominence of cloud computing and artificial intelligence(AI) in software development
3.the emergence of high level programming languages(Fortan)
4.the development of structured programming methodologies


List and briefly explain the phases of the Software Development Life Cycle.
1. planning.
   this is the foundation of any successful software development project. the goals, objectives and the requirements are gathered and documented. the requirements usually are based on customer feedbackor rather the market research evaluating existing products options. planning establishes the project's directionand ensures that all participants have a clear understanding of what needs to be done and how to achieve results.
2. feasibility analysis
   once planning is complete, the feasibility analysis phase begins. the project team now evaluates whether the project is technically and financially viable by assessing the technical requirements, estimating costs and performing a risk analysis.
3. system design
this phase includes creating the software's structure and design based on the requirements gathered during planning by creating a blueprint  outlining how the software will function. 
4. implementations
   this phase is also known as the development phase. the design is beign transformed into a functional application. actual coding takes place at this stage. the developers writes codes based on the design specifications. and ensures the results is efficient, secure and maintainable.
5. testing
  this phase is critical because it generates essential performance and usability feedback while revealing defects and quirks.the main objective of this stage is to identify and fix bugs by ensuring that the software operates as intended before being deployed to users. 
6. deplpoyment
 after the tasting is complete,the solution is now deployed to end users. this typically includes a beta testingphase oe pilot launch that is limited to a selected group of real world users.
7. maintainance
this is the last phase. even after the software is deployed, ongoing support is necessary to address issues, apply updates and add new features. continuous maintainance ensures that the software remains functional and relevant over time.  
 


Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate
waterfall model
agile models


Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.
role and responsibilities of a software developer in a software engineering team
a software developer is  responsible for writing the code and developing the entire software product. Aside from coding, a software developer is responsible for sending updates to the project manager and working closely with other team members, including the designer and QA engineer.
role and responsibilities of a quality assuarance engineer in a software engineering team
Design test plans, scenarios, scripts, or procedures. Document software defects, using a bug tracking system, and report defects to software developers. Identify, analyze, and document problems with program function, output, online screen, or content.
Role and Responsibility of Project Manager in a software engineering team
Planning Everything from Execution to Delivery.
Oversee the Software Development Team.
Delegating Work Effectively.
Monitoring Progress and Tracking Roadblocks.
Managing the Deployment Deliverables.


Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.
An integrated development environment (IDE) is a software application that helps programmers develop software code efficiently.Examples of IDEs include NetBeans, Eclipse, IntelliJ, and Visual Studio.It increases developer productivity by combining capabilities such as software editing, building, testing, and packaging in an easy-to-use application. Just as writers use text editors and accountants use spreadsheets, software developers use IDEs to make their job easier. IDEs are equipped with a host of features, such as code completion, syntax highlighting, and error detection, that can speed up the coding process.
Version control systems are software tools that help software teams manage changes to source code over time.example of version control. Git is a popular version control system. You can use Git to manage the versions of your computer programs and work on programs in conjunction with other developers. Git is itself a computer program.Version control enables the current team to analyze the deletion, editing, and creation of datasets made since the original copy. It brings clarity to the development of the software. It ensures that different versions of the document are distinguishable from each other. So, it is easy to identify the latest version.Version control software facilitates coordination, sharing, and collaboration across the entire software development team. It enables teams to work in distributed and asynchronous environments, manage changes and versions of code and artifacts, and resolve merge conflicts and related anomalies.




What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
Software Engineering Challenges
Whether they’re trying to stay current on shifting technology trends or dealing with limited infrastructure and resources, skilled software engineers are trained to anticipate and overcome various challenges in the workplace. The resulting experience gained helps these professionals adjust and adapt to the ever-changing demands of the job. Below are some common challenges that software engineers face throughout their careers.

Challenge 1: Rapid Technological Advancement
The rapid pace of technological advancement places considerable pressure on software engineers to stay current. In their day-to-day work, they tackle diverse tasks, such as mastering technology stacks (integrated combinations of programming languages, frameworks, and tools) and leveraging software libraries (pre-written code for common functionalities). Beyond writing and debugging code, successful engineers stand out by adopting continuous learning practices and using agile methodologies to adapt to emerging trends, keeping their skills sharp in an ever-evolving industry.

Challenge 2: Growing Customer and Client Demands
Software engineers generally work on conceptual projects designed and developed to meet customer and client demands. Even within the most straightforward application or product development cycles, software engineers must understand underlying business concepts to ensure that the required features satisfy end users’ needs.

Challenge 3: Time Constraints
Software engineering is a demanding and time-intensive field, often requiring engineers to work under high pressure to meet tight deadlines. Collaborating with clients across different time zones further amplifies these challenges. Strict time constraints can impact a development team's efficiency, potentially resulting in lower-quality outcomes. To address these challenges, effective time management strategies are essential. Many teams adopt agile methodologies, such as Scrum, to streamline workflows by dividing large projects into manageable sprints. This approach promotes better organization, enhances productivity, and helps ensure deadlines are met without compromising quality.

Challenge 4: Limited Infrastructure
A shortage of IT resources—or the outright lack of a stable IT infrastructure—constitutes one of the toughest challenges that software engineers face in the modern tech landscape. This may include limited high-performance software engineering tools and computing platforms in addition to inefficient data storage architectures. Software engineers must rely heavily on a robust infrastructure to perform their jobs effectively.

If the necessary hardware and software resources aren’t available or accessible, productivity among software engineering teams may be reduced, affecting a product's or service's overall results.

Challenge 5: Software Testing Conflicts
Conflicts between software engineers and quality assurance (QA) testers can often arise during software development projects. Engineers may prioritize rapid feature delivery, while testers focus on ensuring stability and reliability, leading to potential disagreements over timelines and release readiness. These challenges are often driven by mounting work pressures, differing perspectives on product quality, and contrasting roles and responsibilities within the team. If not managed effectively, such conflicts can compromise the project's integrity, delay software releases, and negatively impact the final product. Open communication, collaborative planning, and clear role definitions are essential to mitigating these issues and ensuring a smooth development process.

Challenge 6: Changing Software Requirements
Software requirements are often dynamic and subject to frequent changes, making it challenging for engineers to design and develop solutions that meet users' needs while accounting for future updates and bug fixes. This challenge becomes even more pronounced when creating cutting-edge software that users expect to rely on for years. To navigate these complexities, engineers can adopt approaches like agile development, which emphasizes iterative progress and adaptability, and modular design, which enables flexibility by breaking systems into manageable, independent components. Together, these strategies help engineers respond effectively to evolving requirements while maintaining high-quality outcomes.

Challenge 7: Software Security
Programming secure software is a complex and challenging task in part because cybercriminals can exploit many different types of vulnerabilities. It might be difficult for software engineers to implement secure software features if they do not actively research ways to defend against hacking, malware, phishing, insider and third-party threats, and more.

Challenge 8: Software Scalability and Availability
Software that isn’t designed to scale up can quickly become a bottleneck as the number of users and frequency of user interactivity increase. Such a bottleneck often leads to performance problems, outages, and in some cases, data loss.

To write scalable and widely available software, engineers need to:

Use scalable architecture.
Incorporate efficient algorithms and data structures.
Practice server load balancing.
Emphasize reliability.
Test for crashes, errors, and other bugs.
Develop a disaster recovery plan in case of emergencies.
Challenge 9: Software Accessibility and Usability
Overly complex software can frustrate or confuse users. Software engineers and developers should remember to build user-friendly assets, keep user interface (UI) designs consistent, and solicit user feedback frequently. Engineers must test software thoroughly and monitor software both during production and after it’s launched.



Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
Level 1: Unit Testing
Unit testing is a fundamental software testing process that tests individual software system components. This level tests each unit's internal architecture and ensures they work as expected.

Who Will Perform The Test?
Developers: Create structured and maintainable code with tests to catch issues early and modify them more easily.
Technical Architects: Join test progress and coding review to verify they follow best practices.
Benefits
Improvement of Code Quality: Unit testing helps developers arrange their code.
Early Detecting Bug: It finds bugs early in the software development life cycle, making them easier and cheaper to fix.
Refactoring Confidence: The concept is that unit tests will be able to detect hidden regressions, giving developers confidence in rewriting code.
Challenges
Resembling Dependencies: Unit tests often require simulating external dependencies, which can be difficult.
Testing Coverage: Large codebases may make executive unit test coverage challenging.
Testing maintenance: Unit tests are good code quality indicators and must be retained and adjusted for code changes.
Level 2: Integration Testing
After unit testing, integration testing evaluates how well these individual components work together. It guarantees each software component. This level of testing integrates two or more unit-tested modules to test technique interactions. The results will show if these modules function as planned.

Who Will Perform The Test?
Developers: Find component interconnections and define test interaction. Then, fixing these test interaction challenges.
Testers (QA): Plan, coordinate, perform, and evaluate integration tests. Then, explain and track the test results.
Technical Architects: Create risk and significance-based module test plans. Develop and manage integration-simulating test environment.
Benefits
Early Integration Issues Detection: Able to find interface, data transfer, and synchronization issues that unit testing missed.
Stability Improvement: Make sure the modules are put together so that the final form of a software system is consistent.
Reduced Regression Risk: Avoid changes in one module affecting other connected modules.
System Functionality Confidence: Use evidence to boost system functionality confidence.
Challenges
Complexity: Testing between modules is harder than testing in the unit. Therefore, efforts must be coordinated.
Dependency Management: Some outside systems could slow down the Integration testing process.
Test Case Design Challenge: Developers must understand module-integration point interactions to construct successful test cases.
Best Practices
Identify Integration Points: Identify the interfaces and data exchange points between tested components.
Start Incremental Integration: Start by integrating a few modules and gradually increase the complexity.
Mock External Dependencies: Utilize mocking techniques to replicate their behavior during testing if external dependencies are not available.
Automate Test Execution: Automate integration tests whenever possible to shorten the testing process and assure consistency.
Focus Key Functionality: Prioritize testing core functionality and module interactions first.
Clear Documentation: Record the integration testing approach, test cases, and expected outcomes for future reference and maintenance.
Level 3: System Testing
System testing is a comprehensive evaluation of a software system's overall functionality and performance. It ensures that the entire system meets the development criteria. This level of testing is critical for detecting system-wide issues such as compatibility problems, performance bottlenecks, and security weaknesses.

Who Will Perform The Test?
QA Testers: Create and run detailed test cases, analyze findings, find faults, and report them to developers or specialists.
Technical Architects: Help organize test phases, prioritize modules for integration testing by risk, and build test environments that simulate real-world integration scenarios.
Domain Experts: Verify that software in specialized fields (banking, healthcare, etc.) meets industry standards and regulations.
End-Users: Provide input on the system's usability, functionality, and user experience issues in the final stages of testing.


Benefits
System Quality Improvement: Help detect and address major issues that may influence the overall quality and functionality of the product.
UX Issues Recognization: Identify usability issues and ensure that the system is intuitive and easy to use.
Reliability Strengths: Identify performance bottlenecks, memory leaks, and other issues that may affect the system's stability and reliability.
Challenges
Time-consuming: Be costly and time-consuming due to the complicated test settings and scenarios.
Test Environment Complexity: Be difficult to create a realistic test environment that closely resembles the production environment.
Requirement Coverage: Be challenging to ensure that all system needs are thoroughly tested.
Limited Scope: Focus on overall system functionality rather than specific components.
Best Practices
Clear Test Objectives: Define system testing goals and scope based on system requirements and user demands.
System Design Documents: Use system design documents to identify critical components, functionality, and testing risks.
Set Test Case Priority: Prioritize testing core functions and user workflows.
Multiple Testing Methods: Combine testing methods like black-box testing, performance testing, and security testing to ensure comprehensive coverage.
Test with End-Users: Gain valuable feedback on user experience and real-world functionality feedback with user acceptability testing (UAT).
Record Test Results: Record test findings, issues, and solutions for future reference.
Level 4: Acceptance Testing
Acceptance testing is the final stage of software testing, which ensures the software functions properly in the user's working environment. It determines whether the software fits the business requirements and user acceptance criteria as expected or not. 

Unlike earlier testing levels, acceptance testing assesses the system from the user's perspective, not the technical functionality.

Who Will Perform The Test?
Testers (QA): Be responsible for the planning, execution, and evaluation of acceptance tests.
End-users: Participate in User Acceptance Testing (UAT), a sort of acceptance testing that provides real-world input on the system's usability, functionality, and intuitiveness.
Stakeholders (clients, product owners, and business analysts): Involved in creating acceptance criteria,  evaluating test findings, and ultimately approving the software for release.
Developers: Collaborate with testers to understand the nature of identified issues better, provide technical insights, and ensure reported problems are fixed effectively.
Benefits
Enhanced User Experience: Acceptance testing identifies and addresses usability issues, ensuring an intuitive and satisfying system.
Reduced Release Defects: By identifying major issues before deployment, acceptance testing reduces the risk of releasing flawed software that may negatively impact user experience.
Increased Trust: Successful acceptance testing fosters trust among stakeholders that the software is ready for production and meets their established requirements.
Business Needs Gaps Realization: Acceptance testing can show disparities between designed software and actual business requirements, prompting crucial changes before deployment.
Challenges
Subjectivity of User Acceptance Criteria: User acceptance criteria can be ambiguous and subjective, which makes it difficult for developers to improve the software.
Limited Expertise: Testers with insufficient domain knowledge may miss critical user experience issues or struggle to develop effective test cases.
Scope Creep: Acceptance testing might result in scope creep and delays if new requirements or changes are not properly managed during testing.
Best Practices
Clear Acceptance Criteria: Define clear, measurable, and achievable acceptance criteria for each system capability based on user demands and business goals.
Early Stakeholder Involvement: Start acceptability testing with stakeholders to gather input and ensure expectations are met.
Prioritize Testing: Prioritize testing important functions and user workflows to maximize efficiency and focus on areas with the highest impact.
Change Management Process: Establish a clear method for handling acceptance testing requirements and changes to prevent scope creep and delays.
Conclusion
The 4 levels of testing in software testing – unit testing, integration testing, system testing, and acceptance testing – ensure the quality throughout the software development. By implementing these rigorous testing phases in all of your projects, the tester can uncover any flaws in the system as soon as possible, saving time and money in the long run and, finally ensuring the delivery of high-quality and robust software.

#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.
Prompt engineering is the process where you guide generative artificial intelligence (generative AI) solutions to generate desired outputs. Even though generative AI attempts to mimic humans, it requires detailed instructions to create high-quality and relevant output. In prompt engineering, you choose the most appropriate formats, phrases, words, and symbols that guide the AI to interact with your users more meaningfully. Prompt engineers use creativity plus trial and error to create a collection of input texts, so an application's generative AI works as expected.
Why is prompt engineering important?
Prompt engineering jobs have increased significantly since the launch of generative AI. Prompt engineers bridge the gap between your end users and the large language model. They identify scripts and templates that your users can customize and complete to get the best result from the language models. These engineers experiment with different types of inputs to build a prompt library that application developers can reuse in different scenarios.

Prompt engineering makes AI applications more efficient and effective. Application developers typically encapsulate open-ended user input inside a prompt before passing it to the AI model.
 benefits of prompt engineering.

Greater developer control
Prompt engineering gives developers more control over users' interactions with the AI. Effective prompts provide intent and establish context to the large language models. They help the AI refine the output and present it concisely in the required format.

They also prevent your users from misusing the AI or requesting something the AI does not know or cannot handle accurately. For instance, you may want to limit your users from generating inappropriate content in a business AI application.

Improved user experience
Users avoid trial and error and still receive coherent, accurate, and relevant responses from AI tools. Prompt engineering makes it easy for users to obtain relevant results in the first prompt. It helps mitigate bias that may be present from existing human bias in the large language models’ training data.

Further, it enhances the user-AI interaction so the AI understands the user's intention even with minimal input. For example, requests to summarize a legal document and a news article get different results adjusted for style and tone.
Increased flexibility
Higher levels of abstraction improve AI models and allow organizations to create more flexible tools at scale. A prompt engineer can create prompts with domain-neutral instructions highlighting logical links and broad patterns. Organizations can rapidly reuse the prompts across the enterprise to expand their AI investments.

For example, to find opportunities for process optimization, the prompt engineer can create different prompts that train the AI model to find inefficiencies using broad signals rather than context-specific data. The prompts can then be used for diverse processes and business units.



Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective 
Incomplete Information: Prompts that lack necessary context or information may result in incomplete or irrelevant responses.
Example: “Write a news report.” 
improved prompt-"Write a news report about improved living standards of Kenyans."
A well-crafted prompt establishes the tone and direction for your writing. It can spark creativity and help you concentrate your ideas.

